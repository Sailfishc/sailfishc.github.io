<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>橙小张的博客</title>
    <link>https://blog.sailfishc.cn/</link>
    <description>Recent content on 橙小张的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Thu, 26 Mar 2020 13:55:37 +0800</lastBuildDate>
    
	<atom:link href="https://blog.sailfishc.cn/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>LeetCode 283. Move Zeroes</title>
      <link>https://blog.sailfishc.cn/algorithm/leetcode283-movezeros/</link>
      <pubDate>Thu, 26 Mar 2020 13:55:37 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/algorithm/leetcode283-movezeros/</guid>
      <description>题目解读 Given an array nums, write a function to move all 0&#39;s to the end of it while maintaining the relative order of the non-zero elements. Example: Input: [0,1,0,3,12] Output: [1,3,12,0,0] Note: 1. You must do this in-place without making a copy of the array. 2. Minimize the total number of operations.  注意点：
  维持数组的相对顺序，也就是不能改变非0元素的相对顺序 不使用新的数组 最少的操作数（操作数指的是对数组的赋值操作）  思路  这道题难度是easy，思路也比较简单，有点类似快慢指针的做法
  定义一个索引nonZero（慢指针），定义为在[0, nonZero]的元素都是符合条件的 遍历数组，索引下标为index（快指针） 如果index对应的值不等于0，则将index的值赋值给nonZero索引，将index和nonZero索引向后移动 如果index对应的值等于0，则只移动index的值 直到index遍历结束 这个时候nonZero的之前的元素已经是数组中全部不为0的数了，只需要把(nonZero, 数组长度)的值赋值为0即可  代码 public void moveZeroes(int[] nums) { if (nums == null || nums.</description>
    </item>
    
    <item>
      <title>工作四年的一些思考</title>
      <link>https://blog.sailfishc.cn/posts/2020/03/%E5%B7%A5%E4%BD%9C%E5%9B%9B%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</link>
      <pubDate>Wed, 25 Mar 2020 14:59:49 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/posts/2020/03/%E5%B7%A5%E4%BD%9C%E5%9B%9B%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</guid>
      <description>写在之前 16年毕业，工作快4年，就职了2家公司，感受过稳定发展，也感受过中型公司无尽的会议和创业公司在寻求业务发展和技术快速实现的矛盾，今天是在公司的最后一天，偷得一日闲，回顾下自己毕业之后这几年工作的一些经历和感悟。
毕业 第一阶段 二本毕业，基本上毕业就失业，但好在大三的时候自己一个人从兰州跑到北京来学习了一段时间，因为这个事情，从预备党员降级为了团员💔，大四的时候又从兰州到北京，开始找工作，面试蛮不顺利的，差不多面了一周多，面了有5家公司，因为还没毕业，也没有好的学校背景，技术也很一般，只有最后一家公司给了Offer，这是一家做电商的公司，公司的主要业务在线下的门店，线上的交易比较少，所以工作上也没有太多挑战，一块入职的几个同事都是刚毕业的，在公司里，有种还在上学的错觉，大家遇到问题一块讨论，工作强度也不大，有大量的时间去学习，但是对于刚毕业的我来说，可以接触到的资源还是太少，公司也没有技术实力比较强的人指导，自己当时是属于百度+知乎+CSDN+简书派程序员，除了看书就是刷刷视频学习学习，那段时间下来，感觉自己知道的特别多，后来也意识到在深度上差太多，有时候自己知道自己哪里有问题，但是不容易迫使自己去改变，在第一家公司工作了一年多，后来觉得自己在这边的环境下不能再成长太多了，有了萌生换一份工作的想法。
第二阶段 这次面试其实还是蛮顺利的，只面了京东，易宝支付和链家，拿到了两个Offer，链家面试官挺好的，但是技术还是达不到他们的要求，最终去了易宝支付，在易宝支付开始了新的职业生涯。
新的工作还是比较有挑战的，在这边主要处理的是资金相关的系统，每天交易流水都比较大，因为负责的系统不是一个快速迭代的系统，已经进入了维护阶段，开发的工作量也不是很大。在这份工作中，自己开始了正式的互联网研发流程（是的，第一家公司的不算正规的研发流程），这时候的我，对于维护的系统上线是很恐慌的状态，我认真的对待自己的代码，也努力的去熟悉以前的代码，深刻的认识着遗留代码的恶臭味，太多的魔法值，不规范的异常处理，关键的流程中没有日志，混杂着不同的远程调用协议，数据库索引不正确的设置，定制化逻辑，对于NULL和””不合理应用，NPE问题，超长的函数，超级大的类，不知道什么意思的配置文件，巨多的定时任务，不完善的UnitTest，经过好几年产品也搞不清楚的业务逻辑，都充斥在这个系统中，当时对于这些，我浑然不知。每次调整代码上线都比较紧张，即便是测试通过了，但是到线上也可能会出现一些莫名其妙的问题，这也就是所谓的泥潭吧，这段时间里，我的技术能力感觉没有提升，唯一提升的就是胆子变大了。
由于组织架构调整，2017年年底部门独立为一个子公司，我们开始创业了，作为第一批员工，赋予了新的意义，那就是要做成一件事情，因为有了公司期权了，老板想着要上市，干劲十足。
第三阶段 这份工作经历，从2017年年底到今天差不多2年3个月的时间，深刻的体会到了创业的困难程度，作为一个创业公司，算是比较幸福的，因为有盈利的业务，在第一年没有为钱担心过，但是公司得有新的血液注入，开始做起了新的产品，快速的产品迭代，不断的添加新的功能，做不完的需求，写不完的代码，时间快速的过去了365天，好像，做了一年了，做的产品在市场激起一朵浪花，是的，一朵也没有，第二年总结会上总结第一年的失败是由于没有及时的做市场推广导致的，开始了扩招销售的策略，当然，功能是不可能停止的，开发是不可能停止的，又过去了365天，依然，没有激起浪花，这就是创业的残忍之处，付出了两年青春，事情还是没有做成，早已不说上市走向认识巅峰，重要的是活下来，这期间经过了多次裁员，团队的很多人早已经没有了继续下去的动力，是时候选择离开了。
第四阶段 这两年写了很多代码，对于需求可以多快好省的完成，但是作为一个有追求的程序员，要抛下诗和远方，去休福报了。
感悟  前面说了这么多，开始聊聊自己这几年的一些感悟吧！
 时间成本  李永乐老师的科普视频中有一个例子：一年120的爱奇艺会员要不要买？
 这给问题可以用数学来计算一下：
 假如我是一个程序员，一天工作8小时，一个月上班22天（当然这些时间作为程序员都是不可能的），那么你一个月的工时就是：176小时，假设工资一个月为17600，那么时薪就是100元。 假如你每天看两个视频，一个视频广告时间为60s，那么一天是2分钟，一个月就是60分钟  如果不开会员，你就浪费了1个小时的时间来看广告了，你的时薪是100元，一个月的会员费为10元，很明显，你是开一个会员比较划算的。
这个思考对我影响很大，那就是对自己的时间有一个金钱衡量的方式，自己在做一些事情的时候可以有一个标准，哪些事情是值得做的，哪些是不值得做的。之前做的很多事情都是没有价值的，比如费时间去找一些破解的软件和视频，还不如多花点时间提升自己。
提升自己的技术深度  他问，“如果用5年的时间学习数据库，你能不能成为这个领域的专家？”
我说，“应该可以吧”
他说，“你现在25，5年后也才30，30岁就能成为某个领域的专家，为什么不去做呢？你看看周围有多少30岁的人还一事无成，而那个时候的你已经是数据库专家了。”
 这是我看的一篇公众号文章的一部分内容，对我也是有一些启发意义的，我知道自己的问题是喜欢看很多东西，但是没有深入的钻研，所以现在还是一个差不多先生，没有特别精通的一部分内容，多给自己一些时间去做一件事情，也许在一段时间内，你不知道微服务，你不知道Python有多火，但是如果坚持一件事情深度的去钻研，我相信，用不了几年时间，会比身边的人强很多，这个建议给你，也给我。
有效的学习，而不是为了学习而学习 在朋友圈经常会看到一些内容，刚看完极客时间的一个专栏文章，在朋友圈发了一小部分总结：
  主从原理：主库通过同步binlog到从库，relaylog去读 从库有延迟可以通过缓存，冗余数据解决 XXX   如果只是这种总结的话， 没什么作用，学习如何学习真的是一门长期探索的事情，不要只会看书做笔记，看视频写笔记，笔记写了很多，但是遇到需要的时候还是不知道如何去做，有一个例子是前两年得到的讲认知的一门课程，教你如何读书，但是你学习了之后还是不会按照他的学习方法去做。
这里推荐几个学习资源：
 Learning How to Learn: Powerful mental tools to … - Coursera 费曼学习法 学习金字塔  留出10%的时间去探索 拿出10%的时间用来探索未来，可以去找一些奇淫技巧，找一些提升自己效率的软件，寻求一些可以用来学习的网站，就像Google给员工20%的时间自己创作一样，给自己10%的事情去做一些探索未来的事情。
算法和英语 先进的技术，优质的资源，英语占了很大一部分，李笑来是一个很典型的例子，早期接触比特币，之后的事情大家都知道了。
算法能力是大厂的敲门砖，也可以改变自己的思维方式，只强调一点，不要为了刷题而刷题。
头脑预演  举个亲身例子，很多人都有用线程的经验，可是有多少人知道线程的本质是什么？有多少人在头脑里有一幅画面，显示出多线程程序的各种动态特征？其实很少有人知道。这就是为什么很多人过度的使用线程并发，结果产生各种同步问题，竞争状态（race condition），死锁等现象。某公司的一片多线程代码，号称是“有非常多并发程序经验”的程序员写的。结果没多久我就发现里面其实含有非常微妙的竞争情况，会在非常小的概率随机发作。</description>
    </item>
    
    <item>
      <title>常用的生产力工具</title>
      <link>https://blog.sailfishc.cn/posts/2020/03/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Wed, 25 Mar 2020 10:28:14 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/posts/2020/03/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/</guid>
      <description>比较喜欢收集信息，对于APP也会找各种各样的去尝试（不太符合极简风格），从Mac，手机，IPad和Chrome Extension都挺多的，这里的包含了大部分的应用，作为记录。
 Mac  1Password 7 AdGuard Affinity Designer Affinity Photo AirServer Alfred 3 Anki Bear calibre Charles CheatSheet ClashX CloudMounter Dash Docker Drafts Dropbox Eagle Emacs Evernote feedly Figma Firefox GitKraken Google Chrome HandShaker Hidden Bar IINA iStat Menus iTerm JetBrains Toolbox JustFocus Kap Kawa Kindle MacUpdater Magnet mat Microsoft To Do MindNode Neat Reader NeatDownloadManager Notion OmniGraffle OneDrive PicGo Pliim Postman ScreenFlow Setapp Slack Spotify Station Studio 3T Surge Telegram Lite Typora uPic Visual Studio Code Wireshark zoom.</description>
    </item>
    
    <item>
      <title>LeetCode189 RotateArray</title>
      <link>https://blog.sailfishc.cn/algorithm/leetcode189-rotatearray/</link>
      <pubDate>Sat, 21 Mar 2020 19:32:55 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/algorithm/leetcode189-rotatearray/</guid>
      <description>Given an array, rotate the array to the right by k steps, where k is non-negative. Example 1: Input: [1,2,3,4,5,6,7] and k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2: Input: [-1,-100,3,99] and k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100] Note: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</description>
    </item>
    
    <item>
      <title> LeetCode 239. Sliding Window Maximum </title>
      <link>https://blog.sailfishc.cn/algorithm/leetcode239-slidingwindowmaximum/</link>
      <pubDate>Sat, 14 Mar 2020 16:34:51 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/algorithm/leetcode239-slidingwindowmaximum/</guid>
      <description>这道题最开始看其实思路比较简单，但是做的时候发现实现还是挺麻烦的，题目的难度也是Hard，先说说自己做这道题目最开始的一个思路：
 为了方便描述，把输入定义为[1,3,-1,-3,5,3,6,7], k = 3 滑动窗口的移动有两种情况，一种是从窗口从索引0 -&amp;gt; 2移动，另外一种就是窗口长度已经是3之后的窗口移动   下面是自己最开始的思考过程，自己第一遍没有做出来，但是思路是比较接近答案的，这也就是算法中如果没有好的数据结构代码会写的又长又臭的原因
  第一步：对于[1,3,-1]的处理 第二步：对于最大值的处理，最开始想到的是定义一个max变量，然后使用Math.max(max, nums[i])这种方式去处理 第三步：移动窗口，用新进入窗口和上一个窗口最大值作比较，但是这一步有一种特殊情况，那就是得处理上一个窗口移出的值是不是最大值，比如[3,-1,-3中最大值是3，但是移动后，3已经被移除了，当前窗口的最大值是-1，为了解决这给问题自己最开始的思路是添加一个变量去记录是不是上一个窗口的第一个元素  解法一 public static int[] maxSlidingWindow(int[] nums, int k) { if (nums == null || nums.length == 0 || nums.length &amp;lt; k) { return new int[0]; } Deque&amp;lt;Integer&amp;gt; deque = new LinkedList&amp;lt;&amp;gt;(); int[] res = new int[nums.length + 1 - k]; for (int I = 0; I &amp;lt; nums.length; I++) { if (!</description>
    </item>
    
    <item>
      <title>如何学习SICP</title>
      <link>https://blog.sailfishc.cn/posts/2020/03/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0sicp/</link>
      <pubDate>Sun, 08 Mar 2020 18:48:42 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/posts/2020/03/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0sicp/</guid>
      <description>这是一篇资源篇，主要是整理了SICP课程的一些资源，包含了Python版的资源和Schema资源，这篇博客主要从几个方面来介绍如何去学习SICP：
  为什么要学习SICP SICP选择Python版还是Schema版本  为什么要学习SICP 先看下国外一些大神是如何评价SICP的：
 I’ve only ever seen one great book on the subject of computer programming: Structure and Interpretation of Computer Programs (Abelson and Sussman; MIT Press). If you’re already a great programmer, it will take you an evening to read the first few chapters and you’ll discover a precision vocabulary for discussing what you’ve spent 10 years learning the hard way. If you’re not already a great programmer, I would have thought that these few chapters would save you from having to spend years flailing around in the dark.</description>
    </item>
    
    <item>
      <title>如何学习英语</title>
      <link>https://blog.sailfishc.cn/posts/2020/03/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E8%8B%B1%E8%AF%AD/</link>
      <pubDate>Sat, 07 Mar 2020 11:11:53 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/posts/2020/03/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E8%8B%B1%E8%AF%AD/</guid>
      <description>&lt;p&gt;这段时间自己一直在学习英语，也一直在寻找适合自己的英语学习方法，买了一些Native English  Speaker和Non-Native English  Speaker的课程，总结下来没有什么捷径，就这几点：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>OKR入门</title>
      <link>https://blog.sailfishc.cn/life/okr/</link>
      <pubDate>Sun, 05 Jan 2020 18:09:12 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/life/okr/</guid>
      <description>定义 OKR = Objective + Key Result + Tasks（Plans）
OKR是目标+关键结果+任务去实现的
什么是OKR？ OKR是“目标和关键结果”的缩写。该概念是在英特尔公司发明的，并已在包括Google和Zynga在内的世界上最大的技术公司中广泛使用。 OKR旨在在指定的时间内为组织和团队设置策略和目标。在工作期结束时，您的OKR提供参考，以评估您在执行目标方面的表现。 花费一致的精力来确定您的公司战略，并使用OKR以易于消化的方式进行规划，可以真正帮助您的员工了解他们如何为全局做出贡献并与其他团队保持一致。
案例  最快的学习方法就是理解更多的例子
 目标：增加系统驱动力  每个地区的司机人数增加20％ 在所有活动区域中，将驾驶员平均工作时间增加到每周26小时  目标：增加驾驶员的地域覆盖率  将所有活跃城市的覆盖率提高到75％ 在使用高峰时段，将任何覆盖区域的取货时间减少至&amp;lt;10分钟  目标：提高驾驶员幸福感  定义并衡量驾驶员的幸福感评分 将驾驶员幸福感评分提高到75％  目标：增加每位用户的平均观看时间。 假设您一直在跟踪观看时间，则主要结果可能是：
 将总收看时间增加到每天XX分钟 将本机YT应用程序扩展到2个新操作系统 将视频加载时间减少X％  分析  Objective：使我们公司快速发展
  Youtube频道产生100000次观看 在Ins上获取10000的Follow 将网站的自然流量增加20%  分析下这个OKR，Objective是使公司快速发展，但是KR是需要有一定领域知识的，比如YouTube频道的观看次数是不是会使公司发展，INS上的follow会不会使得公司发展，对于外行人来看可能是不了解的，所以设定KR是需要知识的，那对于个人来说，该如何设定属于自己的OKR呢？我总结了下自己遇到的几个问题：
 Objective太大或者是太小 不知道KR如何设定 不清楚用哪些Task去实现目标  一般来说，OKR中的Objective是比较容易确定的（对于个人），但是Objective是不是太大了或者太小了该怎么界定呢？我认为是需要用KR来衡量的，当你清楚你的Objective需要用大于3个KR来实现的话，那么Objective应该是太大了，那如何解决呢？我的建议有两点：
 将部分KR提升为Objective 只实现部分KR  举例来说，如果你的Objective是让身体变好，那么KR有可能是这样的：
 一年去医院看病的次数小于5次 吃药周期小于30天 体重控制在60KG以内 体脂率在20%以内 ………. ………..  这时候你发现KR有很多条，这是有问题的，我的建议是减少KR的个数，选出最重要的几条，例如关于体重和体脂的KR，因为体重和体脂控制好了，会在一定程度减少生病的次数，也就减少了去医院的次数和吃药的周期。</description>
    </item>
    
    <item>
      <title>J.U.C 同步框架（AQS 框架）</title>
      <link>https://blog.sailfishc.cn/posts/2019/12/j.u.c-%E5%90%8C%E6%AD%A5%E6%A1%86%E6%9E%B6aqs-%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Fri, 27 Dec 2019 12:03:29 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/posts/2019/12/j.u.c-%E5%90%8C%E6%AD%A5%E6%A1%86%E6%9E%B6aqs-%E6%A1%86%E6%9E%B6/</guid>
      <description>&lt;p&gt;本文转载自：biezhi.com  &lt;a href=&#34;https://www.cnblogs.com/dennyzhangdd/p/7218510.html&#34;&gt;&lt;a href=&#34;https://www.cnblogs.com/dennyzhangdd/p/7218510.html&#34;&gt;https://www.cnblogs.com/dennyzhangdd/p/7218510.html&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何使用Unit testing健壮Java代码</title>
      <link>https://blog.sailfishc.cn/posts/2019/12/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8unit-testing%E5%81%A5%E5%A3%AEjava%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Tue, 03 Dec 2019 23:57:32 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/posts/2019/12/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8unit-testing%E5%81%A5%E5%A3%AEjava%E4%BB%A3%E7%A0%81/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;前言：&lt;a href=&#34;http://www.yinwang.org/blog-cn/2016/09/14/tests&#34;&gt;测试的道理&lt;/a&gt;，推荐下王垠的博客，这篇博客不会提高你的测试水平，但是有一些理论和方法上的指导。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
  </channel>
</rss>
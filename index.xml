<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>橙小张的博客</title>
    <link>https://blog.sailfishc.cn/</link>
    <description>Recent content on 橙小张的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Sat, 21 Mar 2020 19:32:55 +0800</lastBuildDate>
    
	<atom:link href="https://blog.sailfishc.cn/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>LeetCode189 RotateArray</title>
      <link>https://blog.sailfishc.cn/algorithm/leetcode189-rotatearray/</link>
      <pubDate>Sat, 21 Mar 2020 19:32:55 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/algorithm/leetcode189-rotatearray/</guid>
      <description>Given an array, rotate the array to the right by k steps, where k is non-negative. Example 1: Input: [1,2,3,4,5,6,7] and k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2: Input: [-1,-100,3,99] and k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100] Note: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</description>
    </item>
    
    <item>
      <title> LeetCode 239. Sliding Window Maximum </title>
      <link>https://blog.sailfishc.cn/algorithm/leetcode239-slidingwindowmaximum/</link>
      <pubDate>Sat, 14 Mar 2020 16:34:51 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/algorithm/leetcode239-slidingwindowmaximum/</guid>
      <description>这道题最开始看其实思路比较简单，但是做的时候发现实现还是挺麻烦的，题目的难度也是Hard，先说说自己做这道题目最开始的一个思路：
 为了方便描述，把输入定义为[1,3,-1,-3,5,3,6,7], k = 3 滑动窗口的移动有两种情况，一种是从窗口从索引0 -&amp;gt; 2移动，另外一种就是窗口长度已经是3之后的窗口移动   下面是自己最开始的思考过程，自己第一遍没有做出来，但是思路是比较接近答案的，这也就是算法中如果没有好的数据结构代码会写的又长又臭的原因
  第一步：对于[1,3,-1]的处理 第二步：对于最大值的处理，最开始想到的是定义一个max变量，然后使用Math.max(max, nums[i])这种方式去处理 第三步：移动窗口，用新进入窗口和上一个窗口最大值作比较，但是这一步有一种特殊情况，那就是得处理上一个窗口移出的值是不是最大值，比如[3,-1,-3中最大值是3，但是移动后，3已经被移除了，当前窗口的最大值是-1，为了解决这给问题自己最开始的思路是添加一个变量去记录是不是上一个窗口的第一个元素  解法一 public static int[] maxSlidingWindow(int[] nums, int k) { if (nums == null || nums.length == 0 || nums.length &amp;lt; k) { return new int[0]; } Deque&amp;lt;Integer&amp;gt; deque = new LinkedList&amp;lt;&amp;gt;(); int[] res = new int[nums.length + 1 - k]; for (int I = 0; I &amp;lt; nums.length; I++) { if (!</description>
    </item>
    
    <item>
      <title>如何学习SICP</title>
      <link>https://blog.sailfishc.cn/posts/2020/03/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0sicp/</link>
      <pubDate>Sun, 08 Mar 2020 18:48:42 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/posts/2020/03/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0sicp/</guid>
      <description>这是一篇资源篇，主要是整理了SICP课程的一些资源，包含了Python版的资源和Schema资源，这篇博客主要从几个方面来介绍如何去学习SICP：
  为什么要学习SICP SICP选择Python版还是Schema版本  为什么要学习SICP 先看下国外一些大神是如何评价SICP的：
 I’ve only ever seen one great book on the subject of computer programming: Structure and Interpretation of Computer Programs (Abelson and Sussman; MIT Press). If you’re already a great programmer, it will take you an evening to read the first few chapters and you’ll discover a precision vocabulary for discussing what you’ve spent 10 years learning the hard way. If you’re not already a great programmer, I would have thought that these few chapters would save you from having to spend years flailing around in the dark.</description>
    </item>
    
    <item>
      <title>如何学习英语</title>
      <link>https://blog.sailfishc.cn/posts/2020/03/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E8%8B%B1%E8%AF%AD/</link>
      <pubDate>Sat, 07 Mar 2020 11:11:53 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/posts/2020/03/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E8%8B%B1%E8%AF%AD/</guid>
      <description>&lt;p&gt;这段时间自己一直在学习英语，也一直在寻找适合自己的英语学习方法，买了一些Native English  Speaker和Non-Native English  Speaker的课程，总结下来没有什么捷径，就这几点：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>OKR入门</title>
      <link>https://blog.sailfishc.cn/life/okr/</link>
      <pubDate>Sun, 05 Jan 2020 18:09:12 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/life/okr/</guid>
      <description>定义 OKR = Objective + Key Result + Tasks（Plans）
OKR是目标+关键结果+任务去实现的
什么是OKR？ OKR是“目标和关键结果”的缩写。该概念是在英特尔公司发明的，并已在包括Google和Zynga在内的世界上最大的技术公司中广泛使用。 OKR旨在在指定的时间内为组织和团队设置策略和目标。在工作期结束时，您的OKR提供参考，以评估您在执行目标方面的表现。 花费一致的精力来确定您的公司战略，并使用OKR以易于消化的方式进行规划，可以真正帮助您的员工了解他们如何为全局做出贡献并与其他团队保持一致。
案例  最快的学习方法就是理解更多的例子
 目标：增加系统驱动力  每个地区的司机人数增加20％ 在所有活动区域中，将驾驶员平均工作时间增加到每周26小时  目标：增加驾驶员的地域覆盖率  将所有活跃城市的覆盖率提高到75％ 在使用高峰时段，将任何覆盖区域的取货时间减少至&amp;lt;10分钟  目标：提高驾驶员幸福感  定义并衡量驾驶员的幸福感评分 将驾驶员幸福感评分提高到75％  目标：增加每位用户的平均观看时间。 假设您一直在跟踪观看时间，则主要结果可能是：
 将总收看时间增加到每天XX分钟 将本机YT应用程序扩展到2个新操作系统 将视频加载时间减少X％  分析  Objective：使我们公司快速发展
  Youtube频道产生100000次观看 在Ins上获取10000的Follow 将网站的自然流量增加20%  分析下这个OKR，Objective是使公司快速发展，但是KR是需要有一定领域知识的，比如YouTube频道的观看次数是不是会使公司发展，INS上的follow会不会使得公司发展，对于外行人来看可能是不了解的，所以设定KR是需要知识的，那对于个人来说，该如何设定属于自己的OKR呢？我总结了下自己遇到的几个问题：
 Objective太大或者是太小 不知道KR如何设定 不清楚用哪些Task去实现目标  一般来说，OKR中的Objective是比较容易确定的（对于个人），但是Objective是不是太大了或者太小了该怎么界定呢？我认为是需要用KR来衡量的，当你清楚你的Objective需要用大于3个KR来实现的话，那么Objective应该是太大了，那如何解决呢？我的建议有两点：
 将部分KR提升为Objective 只实现部分KR  举例来说，如果你的Objective是让身体变好，那么KR有可能是这样的：
 一年去医院看病的次数小于5次 吃药周期小于30天 体重控制在60KG以内 体脂率在20%以内 ………. ………..  这时候你发现KR有很多条，这是有问题的，我的建议是减少KR的个数，选出最重要的几条，例如关于体重和体脂的KR，因为体重和体脂控制好了，会在一定程度减少生病的次数，也就减少了去医院的次数和吃药的周期。</description>
    </item>
    
    <item>
      <title>J.U.C 同步框架（AQS 框架）</title>
      <link>https://blog.sailfishc.cn/posts/2019/12/j.u.c-%E5%90%8C%E6%AD%A5%E6%A1%86%E6%9E%B6aqs-%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Fri, 27 Dec 2019 12:03:29 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/posts/2019/12/j.u.c-%E5%90%8C%E6%AD%A5%E6%A1%86%E6%9E%B6aqs-%E6%A1%86%E6%9E%B6/</guid>
      <description>&lt;p&gt;本文转载自：biezhi.com  &lt;a href=&#34;https://www.cnblogs.com/dennyzhangdd/p/7218510.html&#34; target=&#34;_blank&#34;&gt;https://www.cnblogs.com/dennyzhangdd/p/7218510.html&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何使用Unit testing健壮Java代码</title>
      <link>https://blog.sailfishc.cn/posts/2019/12/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8unit-testing%E5%81%A5%E5%A3%AEjava%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Tue, 03 Dec 2019 23:57:32 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/posts/2019/12/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8unit-testing%E5%81%A5%E5%A3%AEjava%E4%BB%A3%E7%A0%81/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;前言：&lt;a href=&#34;http://www.yinwang.org/blog-cn/2016/09/14/tests&#34; target=&#34;_blank&#34;&gt;测试的道理&lt;/a&gt;，推荐下王垠的博客，这篇博客不会提高你的测试水平，但是有一些理论和方法上的指导。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>RSS背后的逻辑</title>
      <link>https://blog.sailfishc.cn/life/rss-basic/</link>
      <pubDate>Sun, 01 Dec 2019 18:09:12 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/life/rss-basic/</guid>
      <description>目录  前言 介绍RSS RSS的背后的逻辑论述 RSS实践 总结 参考资源  前言 其实知道RSS也挺久了，但是一直没应用起来，今天正式的了解了一下，发现RSS其实是很能创造生产力的一种工具。
介绍RSS  RSS (originally ** Site Summary** RDF ; later, two competing approaches emerged, which used the backronyms Rich Site Summary and Really Simple Syndication respectively) [2] is a type of web feed [3] which allows users and applications to access updates to websites in a standardized, computer-readable format
 简单来说：RSS指的是允许以标准化计算机可读的方式让用户和应用程序访问网站更新。
RSS的背后的逻辑论述 RSS的机制和软件设计中的一些方式很像：publish/subscribe发布订阅模式，用户作为服务的消费者，是采用主动去拉取（pull）源信息，还是被动的接收（push）信息，也是一个TradeOff的过程，很明显，对于用户来说，人不能像机器，定时的去（pull）数据下来，因为这样太浪费精力，所以RSS订阅的方式出现，提高了生产力。
可能大家都被这种情况困扰过，接收信息的渠道太多，技术博客，新闻网站，某个关注的人的网站，YouTube频道，某个关注的Twitter动态，关注的UP主的直播，购物网站的商品优惠活动，在现在这样信息满天飞，贩卖焦虑的时期，我们要学会过滤信息，只关注自己关心的优质的内容，并且是可学习的，随着时间的变化，我们只保留了这些最优质的的，和自己最匹配的内容，我们每个人在一天的精力都是有限的，不能在每一天都挨个打开各类APP，去浏览信息，去让我们的碎片时间消耗掉，到最后接受了太多的垃圾信息，没有将信息转化为知识，还消耗了一天的精力。
RSS实践  RSS订阅的过程是对自己信息源梳理的过程，我分析了下我自己的信息输入源：
  个人技术博客 公共技术博客网站的某个人的动态 关注的YouTube频道 关注的Github人和仓库 关注的Twitter人的时间线  不是所有的网站都有RSS订阅的，如果我们想订阅的话需要借助一些工具：</description>
    </item>
    
    <item>
      <title>这可能是最全的Redis分布式锁介绍</title>
      <link>https://blog.sailfishc.cn/posts/2019/11/%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Thu, 21 Nov 2019 07:01:41 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/posts/2019/11/%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BB%8B%E7%BB%8D/</guid>
      <description>目录  分布式锁介绍 分布式锁的应用场景 分布式锁几种实现方式介绍  Redis ZK 数据库  Redis实现分布式锁的实现原理 易宝分布式锁分析 *实现Redis分布式锁的正确操作 实现Redis分布式锁的错误案例 Redis分布式锁的问题 Redisson的原理及Redission的一些讨论 基于Redisson的分布式锁的使用  分布式锁介绍 定义  A distributed lock manager (DLM) runs in every machine in a cluster, with an identical copy of a cluster-wide lock database. In this way a DLM provides software applications which are distributed across a cluster on multiple machines with a means to synchronize their accesses to shared resources .</description>
    </item>
    
    <item>
      <title>开发人员必备的Docker基础</title>
      <link>https://blog.sailfishc.cn/posts/2019/11/%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%BF%85%E5%A4%87%E7%9A%84docker%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sun, 10 Nov 2019 16:01:41 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/posts/2019/11/%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%BF%85%E5%A4%87%E7%9A%84docker%E5%9F%BA%E7%A1%80/</guid>
      <description>Docker简介 说到Docker，我们就来谈谈业务应用从旧时代到Docker的发展历程。
旧时代 旧时代是基于Application运转的，一台服务器（无虚拟机时代）部署多个Application，不管是Windows还是Linux其实是无法保证在一台服务器上稳定安全的运行多个应用的，CPU，内存等公共资源的竞争导致应用极为不稳定。
VM阶段 VM让世界变得美好了，VM算是划时代意义的技术，但是VM不是完美的，VM会占用宿主机额外的CPU,RAM和存储（VM不够轻量级），启动慢。
Linux容器 容器技术出现的比较早，只是Docker将Linux容器技术广泛应用了，Docker解决了VM的问题以外，还有如下优点：
 容易上手 解决了运维中的环境问题及服务调度的痛点  Docker安装 Docker提供了桌面安装和服务器安装，对于开发来说，我们可以归类为：
 Windows平台 Mac平台 Linux平台：Ubuntu/CentOS  Windows平台 硬件要求：
 win10 64位 启用Hyper-V和容器特性  安装步骤：Install Docker Desktop on Windows | Docker Documentation
 下载Docker for windows安装包： https://www.docker.com/products/docker-desktop 根据安装向导安装 成功后再CMD中输入docker version查看版本，如果有版本信息表示安装成功  Mac平台 Mac版本和Windows桌面版安装类似，找到下载包，静默安装即可： - 下载地址：下载Docker for windows安装包： https://www.docker.com/products/docker-desktop
Ubuntu安装  Ubuntu安装：Get Docker Engine - Community for Ubuntu | Docker Documentation  Ubuntu有几种方式安装Docker，我们使用便捷脚本来安装Docker
 在Linux打开Shell 执行：curl -fsSL https://get.docker.com -o get-docker.</description>
    </item>
    
  </channel>
</rss>
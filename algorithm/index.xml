<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithms on 橙小张的博客</title>
    <link>https://blog.sailfishc.cn/algorithm/</link>
    <description>Recent content in Algorithms on 橙小张的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Sat, 14 Mar 2020 16:34:51 +0800</lastBuildDate>
    
	<atom:link href="https://blog.sailfishc.cn/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title> LeetCode 239. Sliding Window Maximum </title>
      <link>https://blog.sailfishc.cn/algorithm/leetcode239-slidingwindowmaximum/</link>
      <pubDate>Sat, 14 Mar 2020 16:34:51 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/algorithm/leetcode239-slidingwindowmaximum/</guid>
      <description>这道题最开始看其实思路比较简单，但是做的时候发现实现还是挺麻烦的，题目的难度也是Hard，先说说自己做这道题目最开始的一个思路：
 为了方便描述，把输入定义为[1,3,-1,-3,5,3,6,7], k = 3 滑动窗口的移动有两种情况，一种是从窗口从索引0 -&amp;gt; 2移动，另外一种就是窗口长度已经是3之后的窗口移动   下面是自己最开始的思考过程，自己第一遍没有做出来，但是思路是比较接近答案的，这也就是算法中如果没有好的数据结构代码会写的又长又臭的原因
  第一步：对于[1,3,-1]的处理 第二步：对于最大值的处理，最开始想到的是定义一个max变量，然后使用Math.max(max, nums[i])这种方式去处理 第三步：移动窗口，用新进入窗口和上一个窗口最大值作比较，但是这一步有一种特殊情况，那就是得处理上一个窗口移出的值是不是最大值，比如[3,-1,-3中最大值是3，但是移动后，3已经被移除了，当前窗口的最大值是-1，为了解决这给问题自己最开始的思路是添加一个变量去记录是不是上一个窗口的第一个元素  解法一 public static int[] maxSlidingWindow(int[] nums, int k) { if (nums == null || nums.length == 0 || nums.length &amp;lt; k) { return new int[0]; } Deque&amp;lt;Integer&amp;gt; deque = new LinkedList&amp;lt;&amp;gt;(); int[] res = new int[nums.length + 1 - k]; for (int I = 0; I &amp;lt; nums.length; I++) { if (!</description>
    </item>
    
  </channel>
</rss>